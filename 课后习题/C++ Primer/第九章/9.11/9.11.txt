（1）vector<int> ilist1; // 默认初始化，vector 为空——size
返回0，表明容器中尚未有元素；capacity 返回0，意味着尚未分配存储空间。这
种初始化方式适合于元素个数和值未知，需要在程序运行中动态添加的情况。
（2）vector<int> ilist2(ilist); // ilist2初始化为ilist的拷贝，
ilist 必须与ilist2 类型相同，即也是int 的vector 类型，ilist2 将具有与
ilist 相同的容量和元素。
vector<int> ilist2_1=ilist; // 等价方式
（3）vector<int> ilist = {1, 2, 3.0, 4, 5, 6, 7}; // ilist
初始化为列表中元素的拷贝，列表中的元素类型必须与ilist 的元素类型相容，在
本例中必须是与整型相容的数值类型。对于整型，会直接拷贝其值，对于其他类型
则需进行类型转换（如3.0 转换为3）。这种初始化方式适合元素数量和值预先可知
的情况。
vector<int> ilist_1{1, 2, 3.0, 4, 5, 6, 7}; // 等价方式
（ 4 ） vector<int> ilist3(ilist.begin()+2, ilist.end()-1);
// ilist3 初始化为两个迭代器指定范围中的元素的拷贝，范围中的元素类型
必须与ilist3 的元素类型相容，在本例中ilist3 被初始化为{3, 4, 5, 6}。
注意，由于只要求范围中元素类型与待初始化的容器的元素类型相容，因此，迭代
器来自于不同类型的容器是可能的，例如，用一个double 的list 的范围来初始
化ilist3 是可行的。另外，由于构造函数只是读取范围中的元素并进行拷贝，因
此使用普通迭代器还是const 迭代器来指出范围并无区别。这种初始化方法特别适
合于获取一个序列的子序列。
（5）vector<int> ilist4(7); // 默认值初始化，ilist4 中将包含7 个
元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4
被初始化为包含7 个0。当程序运行初期元素大致数量可预知，而元素的值需动态获
取时，可采用这种初始化方式。
（6）vector<int> ilist5(7, 3); // 指定值初始化，ilist5 被初始化
为包含7 个值为3 的int。