（a）是错误的。因为泛型算法的一个基本特点是：算法总是通过迭代器操作容器，
因此不能直接向/从容器添加、删除元素，无法改变容器大小。因此，对于copy 算
法，要求目标序列至少要包含与源序列一样多的元素。而此程序中，vec 进行缺省
初始化，它是空的，copy 无法进行。如需改变容器大小，需要使用一类特殊的称为
插入器的迭代器。我们可以将第三个参数改为back_inserter(vec)，通过它，
copy 算法即可将lst 中元素的拷贝插入到vec 的末尾。

（b）这段程序仍然是错误的。粗看起来，reserve 为vec 分配了至少能容纳
10 个int 的内存空间，调用fill_n 时，vec 已有足够空间。但泛型算法对于容器
的要求并不是有足够的空间，而是足够的元素。此时vec 仍然为空，没有任何元素。
而算法又不具备向容器添加元素的能力，因此fill_n 仍然失败。这里，我们还是
需要使用back_inserter 来让fill_n 有能力向vec 添加元素。其实，只有0 有
能力做到这一点，空间大小并不是问题，容器都能根据需要自动扩容。