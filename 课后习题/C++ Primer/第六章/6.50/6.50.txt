可行函数是指形参数量与本次调用提供的实参数量相等且每个实参的类型都与
对应的形参类型相同或者能转换成形参类型的函数。
最佳匹配是指该函数每个实参的匹配都不劣于其他可行函数需要的匹配且至少
有一个实参的匹配优于其他可行函数提供的匹配。
根据上述分析，我们可以推断出：
f(2.56, 42)的可行函数是void f(int, int)和void f(double, double
= 3.14)。但是最佳匹配不存在，因为这两个可行函数各有所长。对于这次调用来
说，如果只考虑第一个实参2.56，我们发现，void f(double, double = 3.14)
能够精确匹配，但是要想匹配第二个参数，int 类型的实参42 必须转换成double
类型。如果考虑第二个实参42，我们发现，void f(int, int)能够精确匹配，
但是要想调用void f(int, int)就必须把第一个double 类型的实参2.56 转换
成int 类型。最终的结果是这两个可行函数各自在一个实参上实现了更好的匹配，
但是把它们比较起来无从判断孰优孰劣，因此编译器将因为这个调用具有二义性而
拒绝其请求。
f(42)的可行函数是void f(int)和void f(double, double = 3.14)，
其中最佳匹配是void f(int)，因为参数无须做任何类型转换。
f(42, 0)的可行函数是void f(int, int)和void f(double, double
= 3.14)，其中最佳匹配是void f(int, int)，因为参数无须做任何类型转换。
f(2.56, 3.14) 的可行函数是void f(int, int)和void f(double,
double = 3.14)，其中最佳匹配是void f(double, double = 3.14)，因
为参数无须做任何类型转换。